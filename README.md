המחלקה NodeInfo+WGraph_DS
	עבור כל Node הגדרתי רשימת שכנים NodeNi מסוג HashMap - HM, המתאימה לכל מפתח של שכן, את המשקל של הצלע בין הקודקוד לשכן.
	בחרתי להשתמש דווקא בHM עבור רשימת השכנים כיוון שמספר השכנים לא בהכרח קבוע וכן יכול להשתנות 
	ואני רוצה מבנה נתונים דינמי יחסית מבחינת שינוי בכמות האובייקטים שבו.
	וחשוב לי לבדוק אם קיימת צלע/ליצור צלע בזמן ריצה O(1), כלומר אני צריכה שחיפוש ברשימת השכנים של קודקוד יהיה ב O(1) וזה מה שHM נותנת לי.
	בנוסף, התאמתי ברשימת השכנים לכל מפתח של שכן- את משקל הצלע כאמור, וזה היתרון של HM שיכולה לבצע התאמה כזאת ושליפה של המשקל בO(1) 
	וכך היא שמשה אותי גם להחזרת משקל של צלע בזמן ריצה זה.

	המחלקה nodeInfo פנימית והוגדרה כציבורית ע"מ לאפשר לי גישה ישירה ונוחה מהמחלקה WGraph_Algo והפונקציות שלה לנתונים של כל קודקוד.
	רשימת הקודקודים: colNode שוב השתמשתי בHM ע"מ להתאים בין מפתח של קודקוד לקודקוד עצמו.
	הוספתי מעבר לפונקציות של ממשק node_info, פונקציות שקשורות בשכנים של קודוקוד.

המחלקה WGraph_Algo
	לשם העתקת גרף (פונקציית copy( יצרתי גרף חדש ואיתחלתי את הנתונים שלו להיות הנתונים של הגרף שאותו אני מעתיקה. בעניין רשימת הקודקודים- יצרתי רשימה חדשה עבור הגרף החדש,
	ואליה הכנסתי שכפול של כל קודקוד (כולל שכפול של רשימת השכנים של כל קודקוד) מרשימת הקודקודים של הגרף המקורי. 

	isConnected - 
	לפני כל בדיקה של המסלול הקצר ביותר, איפסתי משתנים הכרחיים(השדות visited ו tag של כל קודקוד מהגרף) לבדיקה ע"מ  שהבדיקה תצא תקינה, ע"י הפונקציה resetVisited.
	לאחר מכן עבדתי ע"פ אלגוריתם BFS לבדיקת קשירות:
	  הפונקציה BFS() 
		 אלגוריתם BFS:
		 מתחילים מאישזהו קודקוד בגרף, ובודקים את רשימת השכנים שלו, כל פעם שהגענו לשכן, נסמן שביקרנו בו, ועבור כל שכן כזה,
		 ניצור רשימת המתנה של השכנים שלו במידה והם לא בוקרו כבר. וככה נמשיך לעבור עד שנגיע לקודקוד שאין לו שכנים/כולם בוקרו
		 לבסוף נעבור על כל קודקודי הגרף, אם נמצא קודקוד שלא בוקר, זה אומר שלא הצלחנו להגיע אליו מהקודקוד הראשוני בשום צורה
		 ולכן הוא לא מחובר לאותו קודקוד, משמע אין מסלול בינהם, משמע הגרף לא קשיר
		 סיבוכיות: O(V+E) כאשר V- מספר הקודקודים בגרף וE מספר הצלעות בגרף: האלגוריתם עובר על כל קודקוד ועל השכנים שלו, שזה O(V*E) אך כיוון שלא עוברים פעמיים על קודקוד,
		 כלומר לא בודקים אותו אם כבר הגענו אליו דרך צלע אחרת, אז עוברים סה"כ על כל צלעות הגרף עבור כל האלגוריתם, כלומר O(V+E) 

	shortestDistance -
		לפני כל בדיקה של המסלול הקצר ביותר, איפסתי משתנים הכרחיים(השדות visited ו tag של כל קודקוד מהגרף) לבדיקה ע"מ  שהבדיקה תצא תקינה, ע"י הפונקציה resetVisitedAndTag.
		לאחר מכן עבדתי לפי אלגוריתם דייקסטרה,  למציאת אורך המסלול הקצר ביותר, כלומר:
		הפונקציה dijkstra:
			
			אלגוריתם דייקסטרה: 
			יצרתי תור עדיפויות, והתחלתי לעבור על השכנים של קודקוד התחלתי, מהשכן עם המשקל הכי נמוך עד הגבוה ביותר.
			הכנסתי לtag של כל אחד מהם את המשקל שלהם+ הtag של הקוד' ההתחלתי(ששווה ל0) הוספתי אותם לתור כאשר העדיפות היא הtag של כל אחד.
			באיטרציה הבאה עברתי על השכנים של כל אחד מהנמצאים בתור, והתחלתי בקודקוד עם הtag הנמוך ביותר בתור. ושוב עברתי על השכנים שלו,
			לכל אחד מהם- אם הtag שלו יותר גדול מהמרחק(=המשקל של הצלע בין הקודקוד לשכן+ הtag של הקודקוד שממנו הגענו אל השכן), נעדכן את הtag להיות המרחק.
			הכנסתי כל אחד מהשכנים לתור.
			ושוב נסתכל על התור, וניקח את הקודקוד עם הtag הנמוך ביותר (ללא חשיבות באיזה שלב הכנסתי אותו, אלא אם כן יש שני קודקודים בעלי tag זהה)
			ונבצע על השכנים של הקודקוד את אותן פעולות שעשינו על השכנים של הקודקוד הקודם.
			ברגע שהקודקוד עם הtag הכי נמוך בתור יהיה קודקוד היעד, זה אומר שמצאנו אליו את המסלול הקצר ביותר ועברנו כבר על כל הדרכים שיש מקודקוד התחלתי אליו
			ואז נחזיר את הtag שלו ונסיים להשתמש בפונקציה. במידה ואין מסלול אל קודקוד זה נחזיר שהמרחק אינסוף.
			סיבוכיות:O(|E|+|V|log|V|) כיוון שבכל פעם שעוברים על שכן מעדכנים או מוסיפים את הקודקוד והtag שלו, זה קורה |E| פעמים וסיבוכיות הוספה/עדכון היא log(|V).
			בנוסף כל קודקוד מוציאים פעם אחת מהתור, וזה קורה |V| פעמים וסיבוכיות הוצאה היא log(|V)

	shortestDistancePath-
		לפני כל בדיקה של המסלול הקצר ביותר, איפסתי משתנים הכרחיים(השדות visited , tag ו pre של כל קודקוד מהגרף) לבדיקה ע"מ  שהבדיקה תצא תקינה, ע"י הפונקציה resetVisitedAndTagAndPre
		הפונקציה dijkstraPath
			נעבוד שוב לפי אלגוריתם דייקסטרה, רק בכל פעם שנרצה לעדכן tag של שכן כלשהו, נשמור ב"pre" שלו את הקודקוד שממנו הגענו אל השכן, וכך המסלול יישמר לנו.
			את המסלול נבנה בעזרת רשימה, שאליה נוסיף להתחלה את קודקוד היעד, ונמשיך כל פעם להוסיף להתחלה את שדה הpre של הקודקוד הראשון ברשימה. 
			ככה נבנה מסלול בטוח שבודק את המסלול הקצר שבעקבותיו הגענו לקודקוד היעד.

